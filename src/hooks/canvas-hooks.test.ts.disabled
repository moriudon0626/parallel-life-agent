/**
 * Test suite for canvas and game loop hooks
 * Run manually to verify coordinate conversions and performance
 */

import type { Camera2D } from '../useCanvas2D';
import { worldToScreen, screenToWorld, worldDistance, isVisibleOnScreen } from '../useCanvas2D';

// Mock canvas for testing
const createMockCanvas = (width = 800, height = 600): HTMLCanvasElement => {
  return {
    width,
    height,
  } as HTMLCanvasElement;
};

describe('Canvas2D Coordinate Conversions', () => {
  const camera: Camera2D = { x: 0, z: 0, zoom: 20 };
  const canvas = createMockCanvas();

  test('worldToScreen: origin should map to screen center', () => {
    const [sx, sy] = worldToScreen(0, 0, camera, canvas);
    expect(sx).toBe(400); // canvas.width / 2
    expect(sy).toBe(300); // canvas.height / 2
  });

  test('worldToScreen: positive X should move right', () => {
    const [sx, sy] = worldToScreen(1, 0, camera, canvas);
    expect(sx).toBe(420); // 400 + 1 * 20
    expect(sy).toBe(300);
  });

  test('worldToScreen: positive Z should move up (Y-inverted)', () => {
    const [sx, sy] = worldToScreen(0, 1, camera, canvas);
    expect(sx).toBe(400);
    expect(sy).toBe(280); // 300 - 1 * 20 (inverted)
  });

  test('screenToWorld: screen center should map to camera position', () => {
    const [wx, wz] = screenToWorld(400, 300, camera, canvas);
    expect(wx).toBe(0);
    expect(wz).toBe(0);
  });

  test('screenToWorld and worldToScreen should be inverse operations', () => {
    const worldX = 5;
    const worldZ = 3;
    const [sx, sy] = worldToScreen(worldX, worldZ, camera, canvas);
    const [wx, wz] = screenToWorld(sx, sy, camera, canvas);

    expect(wx).toBeCloseTo(worldX, 5);
    expect(wz).toBeCloseTo(worldZ, 5);
  });

  test('zoom affects coordinate conversion', () => {
    const zoomedCamera: Camera2D = { x: 0, z: 0, zoom: 40 };
    const [sx1, sy1] = worldToScreen(1, 0, camera, canvas);
    const [sx2, sy2] = worldToScreen(1, 0, zoomedCamera, canvas);

    // 2x zoom should double the distance from center
    expect(sx2 - 400).toBe(2 * (sx1 - 400));
  });

  test('camera offset affects coordinate conversion', () => {
    const offsetCamera: Camera2D = { x: 10, z: 5, zoom: 20 };
    const [sx, sy] = worldToScreen(10, 5, offsetCamera, canvas);

    // Camera position should be at screen center
    expect(sx).toBe(400);
    expect(sy).toBe(300);
  });
});

describe('Canvas2D Utility Functions', () => {
  test('worldDistance: calculates correct distance', () => {
    const dist = worldDistance(0, 0, 3, 4);
    expect(dist).toBe(5); // 3-4-5 triangle
  });

  test('worldDistance: same point returns 0', () => {
    const dist = worldDistance(5, 5, 5, 5);
    expect(dist).toBe(0);
  });

  test('isVisibleOnScreen: center point is visible', () => {
    const camera: Camera2D = { x: 0, z: 0, zoom: 20 };
    const canvas = createMockCanvas();
    const visible = isVisibleOnScreen(0, 0, camera, canvas);
    expect(visible).toBe(true);
  });

  test('isVisibleOnScreen: far point is not visible', () => {
    const camera: Camera2D = { x: 0, z: 0, zoom: 20 };
    const canvas = createMockCanvas();
    const visible = isVisibleOnScreen(1000, 1000, camera, canvas);
    expect(visible).toBe(false);
  });

  test('isVisibleOnScreen: margin extends visibility', () => {
    const camera: Camera2D = { x: 0, z: 0, zoom: 1 };
    const canvas = createMockCanvas(800, 600);

    // Point just outside screen without margin
    const x = 450; // Just beyond 800/2 + 50 default margin
    const visible = isVisibleOnScreen(x, 0, camera, canvas, 0);
    expect(visible).toBe(false);

    // Same point visible with larger margin
    const visibleWithMargin = isVisibleOnScreen(x, 0, camera, canvas, 100);
    expect(visibleWithMargin).toBe(true);
  });
});

describe('Game Loop Performance', () => {
  test('delta capping prevents physics explosions', () => {
    // Simulate a long freeze (e.g., 500ms)
    const longDelta = 0.5; // 500ms in seconds
    const maxDelta = 0.1; // 100ms cap
    const cappedDelta = Math.min(longDelta, maxDelta);

    expect(cappedDelta).toBe(0.1);
  });

  test('target frame time calculation', () => {
    const targetFPS = 60;
    const targetFrameTime = 1000 / targetFPS;

    expect(targetFrameTime).toBeCloseTo(16.667, 2);
  });

  test('FPS calculation accuracy', () => {
    const frames = 60;
    const timeElapsed = 1000; // 1 second
    const fps = Math.round((frames * 1000) / timeElapsed);

    expect(fps).toBe(60);
  });
});

// Manual test runner (console output)
export function runManualTests() {
  console.group('ğŸ§ª Canvas Hooks Manual Tests');

  console.log('\nğŸ“ Coordinate Conversion Tests:');
  const camera: Camera2D = { x: 0, z: 0, zoom: 20 };
  const canvas = createMockCanvas();

  console.log('Origin (0,0) â†’ screen:', worldToScreen(0, 0, camera, canvas));
  console.log('Point (5,3) â†’ screen:', worldToScreen(5, 3, camera, canvas));
  console.log('Screen (400,300) â†’ world:', screenToWorld(400, 300, camera, canvas));

  console.log('\nğŸ“ Distance Tests:');
  console.log('Distance (0,0) to (3,4):', worldDistance(0, 0, 3, 4));
  console.log('Distance (5,5) to (5,5):', worldDistance(5, 5, 5, 5));

  console.log('\nğŸ‘ï¸ Visibility Tests:');
  console.log('Is (0,0) visible?', isVisibleOnScreen(0, 0, camera, canvas));
  console.log('Is (1000,1000) visible?', isVisibleOnScreen(1000, 1000, camera, canvas));

  console.log('\nâš¡ Performance Targets:');
  console.log('Target: 60 FPS');
  console.log('Frame budget: ~16.67ms');
  console.log('Delta cap: 100ms (prevents physics issues)');

  console.groupEnd();
}

// Export for browser console testing
if (typeof window !== 'undefined') {
  (window as any).runCanvasTests = runManualTests;
}
